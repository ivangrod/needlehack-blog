<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: How-To | Home Assistant]]></title>
  <link href="https://ivangrod.github.io/blog/categories/how-to/atom.xml" rel="self"/>
  <link href="https://ivangrod.github.io/"/>
  <updated>2025-09-23T17:02:13+00:00</updated>
  <id>https://ivangrod.github.io/</id>
  <author>
    <name><![CDATA[Home Assistant]]></name>
    
  </author>

  
  <entry>
    <title type="html"><![CDATA[esphomelib - A comprehensive solution for using ESPs with Home Assistant]]></title>
    <link href="https://ivangrod.github.io/blog/2018/06/05/esphomelib/"/>
    <updated>2018-06-05T06:24:55+00:00</updated>
    <id>https://ivangrod.github.io/blog/2018/06/05/esphomelib</id>
    <content type="html"><![CDATA[The [ESP8266](https://www.espressif.com/products/socs/esp8266) and [ESP32](https://www.espressif.com/products/socs/esp32) are dirt cheap WiFi-enabled microcontrollers that have established themselves as the base for many DIY home automation projects. Even quite a few manufacturers like iTead with their Sonoff devices have chosen these controllers because of their competitive price.

Setting up these microcontrollers for some basic functionality has also gotten really easy over the years with popular projects like ESPEasy or Sonoff-Tasmota: You just download their firmware and flash it onto your chip. But if you‚Äôve ever tried to go a bit beyond the basic set of functions of those frameworks and tried to do some customization, you will have probably noticed that it‚Äôs not that easy. Often times you‚Äôll end up having to download some Arduino code project from the internet and customizing it to your needs.

This is where esphomelib comes in: The [esphomelib suite](https://esphome.io/) is a set of tools that are designed with the goal of achieving the best possible user experience.  esphomelib a) allows for lots of customization without touching *a single line* of code and b) has complete Home Assistant integration. Inside the esphomelib ecosystem, you essentially just have to write a simple YAML configuration file. The rest like compiling, flashing, uploading etc. will then be taken care of automatically.

<!--more-->

## Installation

An example probably illustrates this the best. To use esphomeyaml, there are two main ways: From a [HassIO add-on](https://esphome.io/guides/getting_started_hassio.html), or from the [command line](https://esphome.io/guides/getting_started_command_line.html). For the esphomeyaml add-on, you just have to add "[https://github.com/esphome/esphome](https://github.com/esphome/esphome)" as an add-on repository (see [Installing third party add-ons](/hassio/installing_third_party_addons/)). Then select and install ‚Äúesphomeyaml‚Äù and wait for the installation to complete. After that, you will be able to start the add-on and view the web interface.

From the command line you just need to install the **Python 2** package using the pip command seen below. Then visit `localhost:6052` to view the dashboard.

```bash
pip2 install esphomeyaml
esphomeyaml config/ dashboard
# Alternative for docker users:
docker run --rm -p 6052:6052 -p 6123:6123 -v "$PWD":/config ottowinter/esphomeyaml /config dashboard
```

<div class="videoWrapper">
  <iframe width="853" height="480" src="https://www.youtube-nocookie.com/embed/uWZmc_MjSWs?rel=0&amp;showinfo=0loop=1&amp;autoplay=1" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>

Once in the dashboard interface, you will be greeted by a small setup wizard that will help you get started with esphomeyaml and create a basic configuration. You should end up with a configuration file like this.

```yaml
esphomeyaml:
  name: livingroom
  platform: ESP8266
  board: nodemcuv2

wifi:
  ssid: "MySSID"
  password: "MyPassword"

mqtt:
  broker: "192.168.178.83"
  username: ""
  password: ""

logger:
ota:
```

At this point, you can already flash the firmware. To do this, first plug in the USB cable of the ESP into a USB port of the device esphomeyaml is running on and wait until you see a ‚ÄúDiscovered new serial port‚Äù message (in some cases you need to restart the add-on). Select the upload port in the top navigation bar and press the big "UPLOAD" button. If everything succeeds, you should now have a functioning esphomelib node and see the debug logs üéâ

## Adding some basic functionality

Above configuration is, let‚Äôs face it, pretty dull. It really only connects to WiFi and MQTT and sits idle. So let‚Äôs add a basic [GPIO switch](https://esphome.io/components/switch/gpio.html)! The GPIO switch component in esphomelib allows you to control the ON/OFF state of any of the pins on your ESP. For example, if you add this configuration to the bottom of your YAML file, you‚Äôre setting up the pin `GPIO5` to be controlled as a switch with the name "Living Room Dehumidifer".

```yaml
switch:
  - platform: gpio
    name: "Living Room Dehumidifer"
    pin: GPIO5
```
If you now press upload again (this time the ESP doesn't need to be connected via USB, as updates [can be done over WiFi](https://esphome.io/components/ota.html)), you will see a switch show up in Home Assistant automatically through [MQTT discovery](/docs/mqtt/discovery/).

<p class='img'>
  <img
    src='/images/blog/2018-06-esphomelib/switch.png'
    alt='esphomeyamls setup wizard.'>
  How the newly configured switch will show up in Home Assistant if <a href='/docs/mqtt/discovery/'>MQTT
  discovery</a> is enabled and a <a href='/integrations/group/'>default view</a> is used.
</p>

Granted, this functionality would have been pretty simple with other projects too. But once you start adding [lights](https://esphome.io/index.html#light-components), [covers](https://esphome.io/index.html#cover-components) and [other sensors](https://esphome.io/index.html#sensor-components), esphomelib‚Äôs modular design really starts to shine.

## See Also

- [View the full getting started guide (including how to migrate from other projects)](https://esphome.io/guides/)
- [Device-specific setup guides](https://esphome.io/#devices)
- [List of supported sensors/actuators](https://esphome.io/)
- Join the [discord server](https://discord.gg/KhAMKrd) if you need help.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set up Hass.io on top of a virtual machine]]></title>
    <link href="https://ivangrod.github.io/blog/2017/11/29/hassio-virtual-machine/"/>
    <updated>2017-11-29T06:00:00+00:00</updated>
    <id>https://ivangrod.github.io/blog/2017/11/29/hassio-virtual-machine</id>
    <content type="html"><![CDATA[The images for the Raspberry Pi family and the Intel NUC are an easy way to get started with [Hass.io](/getting-started). For a test or if you have a system which is already hosting virtual machines then the [**Hass.io installer**](/installation/) is an option to use Hass.io in a virtualized environment. In this guide the host is a Fedora 27 system with [libvirt](https://libvirt.org/) support and the guest will be running Debian 9. Hass.io will be installed on the guest.

<!--more-->

Assuming that you already have setup `libvirtd`. You might need to install `virt-builder` and `virt-viewer` additionally.

```bash
sudo dnf -y install libguestfs-tools-c virt-install virt-viewer
```

We will create a virtual machine with Debian 9 and a 10 GB disk image in the QCOW format. Use `$ virt-builder --list` to get an overview about what's operating systems are available if you prefer to use a different system.

```bash
$ sudo virt-builder debian-9 \
    --output /var/lib/libvirt/images/hassio.img \
    --format qcow2 \
    --size 10G \
    --root-password password:test123 \
    --hostname hassio \
    --firstboot-command "dpkg-reconfigure openssh-server"
[...]
[ 147.6] Finishing off
                   Output file: /var/lib/libvirt/images/hassio.img
                   Output size: 10.0G
                 Output format: qcow2
            Total usable space: 9.3G
                    Free space: 8.1G (87%)
```

Now, we are making our new virtual machine available for `libvirtd`. If you get an error that the OS is unknown, use `$ osinfo-query os` to get the name to use with `--os-variant`. To access the virtual machine is connected to the bridge `bridge0`.

```bash
$ sudo virt-install --name hassio --import --ram 1024 \
     --os-variant debian9 -w bridge=bridge0 \
     --autostart --disk /var/lib/libvirt/images/hassio.img
```

<p class='img'>
  <img src='/images/blog/2017-11-hassio-virtual/virtual-machine-manager.png' />
  Hass.io virtual machine in Virtual Machine Manager
</p>

Depending on your preferences you can use the Virtual Machine Manager (`virt-manager`) or `virsh` to manage the created virtual machine. Log in and create an user with `# useradd ha` and set a password with `# passwd ha`. We will need that user to make a SSH connection to the virtual machine.

Log in as `ha` with the given password. If your are using the default network of `libvirtd` then the DHCP range is defined in `/var/lib/libvirt/dnsmasq/default.conf`. In this guide the virtual machine is present at 192.168.0.109.

```bash
$ ssh ha@192.168.0.109
ha@192.168.0.109's password: 
Linux hassio 4.9.0-3-amd64 #1 SMP Debian 4.9.30-2+deb9u3 (2017-08-06) x86_64
[...]
$ 
```

Install the requirements after you switch the user to `root`.

```bash
$ su
Password: 
root@hassio:/home/ha# 
root@hassio:/home/ha# apt-get update
root@hassio:/home/ha# apt-get install bash socat jq curl avahi-daemon \
    apt-transport-https ca-certificates
```

We want the latest Docker release. This requires additional steps to set it up as unlike other distributions Debian is lacking behind with current packages.

```bash
root@hassio:/home/ha# wget https://download.docker.com/linux/debian/gpg 
root@hassio:/home/ha# apt-key add gpg
OK
root@hassio:/home/ha# echo "deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | tee -a /etc/apt/sources.list.d/docker.list
root@hassio:/home/ha# apt-get update
```

Now, it's possible to install a current release of [Docker](https://www.docker.com/).

```bash
root@hassio:/home/ha# apt-get -y install docker-ce
```

Start `docker` and enable it.

```bash
root@hassio:/home/ha# systemctl start docker && systemctl enable docker
```

An [installation script](https://github.com/home-assistant/hassio-build/tree/master/install#install-hassio) will take care about the setup of all moving parts.

```bash
root@hassio:/home/ha# curl -sL https://raw.githubusercontent.com/home-assistant/hassio-build/master/install/hassio_install | bash -
[INFO] Install supervisor docker
[INFO] Install generic HostControl
[INFO] Install startup scripts
[INFO] Init systemd
Created symlink /etc/systemd/system/multi-user.target.wants/hassio-supervisor.service ‚Üí /etc/systemd/system/hassio-supervisor.service.
[INFO] Start services
```

If it's done, then there will be two new containers.

```bash
root@hassio:/home/ha# docker ps
CONTAINER ID        IMAGE                                    COMMAND                  CREATED             STATUS              PORTS               NAMES
ada5bbfc74f0        homeassistant/qemux86-64-homeassistant   "/usr/bin/entry.sh..."   4 minutes ago       Up 4 minutes                            homeassistant
5954ac452ffc        homeassistant/amd64-hassio-supervisor    "/usr/bin/entry.sh..."   7 minutes ago       Up 7 minutes                            hassio_supervisor
```

After a connection to the container which is containing Home Assistant is made, you will see the log output.

```bash
root@hassio:/home/ha# docker attach --sig-proxy=false ada5bbfc74f0
2017-11-28 19:24:30 INFO (MainThread) [homeassistant.core] Bus:Handling <Event state_changed[L]: entity_id=sun.sun, old_state=<state sun.sun=below_horizon; next_dawn=2017-11-29T06:17:58+00:00,...
```

For further details about the container, `inspect` can help.

```bash
root@hassio:/home/ha# docker inspect bb32b525d1ad
[...]
            "OnBuild": null,
            "Labels": {
                "io.hass.arch": "amd64",
                "io.hass.machine": "qemux86-64",
                "io.hass.type": "homeassistant",
                "io.hass.version": "0.58.1"
            }
[...]
```

Hass.io is now ready. The frontend is available at [http://192.168.0.109:8123](http://192.168.0.109:8123). Yes, the IP address is the one of the guest.

<p class='img'>
  <img src='/images/blog/2017-11-hassio-virtual/hassio.png' />
  Hass.io overview
</p>

Keep in mind that there are limitations with this approach. Not all [add-ons](/addons/) will work and some don't make sense to use as the hardware is not present. E.g., use the [SSH community add-on](https://github.com/hassio-addons/addon-ssh) instead of the default [SSH add-on](/addons/ssh/).

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Secure remote access to Home Assistant using Tor]]></title>
    <link href="https://ivangrod.github.io/blog/2017/11/12/tor/"/>
    <updated>2017-11-12T08:00:00+00:00</updated>
    <id>https://ivangrod.github.io/blog/2017/11/12/tor</id>
    <content type="html"><![CDATA[Routers and gateways provided by broadband internet providers are very often limited regarding features and configuration possibilities. Most of these limitations affect the opportunities that allow users to set up port-forwarding, DMZ, and DHCP reservations since the suppliers figured that average user does not want (or should not) deal with these. Making your Home Assistant instance available remotely (and securely), in this case, becomes more difficult. Are you one of those unlucky ones?

There are a couple of options available to achieve a remote (and secure) accessible Home Assistant instance. However, almost all of them require you to: open one or more ports on your router, expose a public IP address, and require you to reserve a fixed IP in your DHCP server (or set up a static IP address). Examples of these are:

- Combination of [DuckDNS](/integrations/duckdns/) (or similar), [Let's Encrypt](/docs/ecosystem/certificates/lets_encrypt/) (SSL), DHCP reservation, and forwarding a port to your device running Home Assistant.
- Setup a VPN, which often requires more hardware and software. Additionally, it also requires port-forwarding, DHCP reservation and most likely [DuckDNS](/integrations/duckdns/) (or similar).
- [SSH tunnel-ing](/blog/2017/11/02/secure-shell-tunnel/). Which still requires port-forwarding, DHCP reservation and most likely (yeah, you've guessed it) [DuckDNS](/integrations/duckdns/) (or similar).

There is, however, another option available that most people do not realize: [Tor](https://www.torproject.org). [Tor](https://www.torproject.org) offers a capability that they refer to as [Tor's Hidden Services](https://www.torproject.org/docs/hidden-services.html.en), which allows you to securely access your Home Assistant installation *without* the need for all these things. No need to forward and open ports, no need to expose your public IP, no DNS entry, no need for SSL certificates, and you do not have to assign a fixed IP to the device running your Home Assistant.

The most amazing part? It is super easy to set up!

<!--more-->

## Setting up Tor

The setup is straight-forward:

1. Install Tor. On a Debian-based system: `$ sudo apt-get install tor`. On Fedora: `$ sudo dnf install tor`
2. Modify Tor's main configuration file `/etc/tor/torrc` to include the following lines:

    ```bash
    ############### This section is just for location-hidden services ###

    ## Once you have configured a hidden service, you can look at the
    ## contents of the file ".../hidden_service/hostname" for the address
    ## to tell people.
    ...
    HiddenServiceDir /var/lib/tor/homeassistant/
    HiddenServicePort 80 127.0.0.1:8123
    ...
    ```
3. Restart Tor: `$ sudo systemctl restart tor`
4. The Tor-generated hostname file contains the hostname you need to access your installation.

    ```bash
    $ sudo cat /var/lib/tor/homeassistant/hostname
    abcdef1234567890.onion
    ```

## Tor add-on for Hass.io

[Franck Nijhof (@frenck)](https://github.com/frenck) created the [Tor add-on](https://github.com/hassio-addons/addon-tor) for [Hass.io](/hassio/). This add-on makes the installation and the setup extremely simple. Go to the **Hass.io** panel, then to the **Store**, copy `https://github.com/hassio-addons/repository` into the text box of **Add-On Repositories** and save it.

A new entry **Tor** will show-up in the list of add-ons. Click on it to install it. The configuration is done in **Options**. Please refer to the [Configuration documentation](https://github.com/hassio-addons/addon-tor#configuration) for further details. A possible configuration could look like the sample below (which is the default configuration).

```json
{
  "log_level": "info",
  "socks": false,
  "hidden_services": true,
  "stealth": false,
  "client_names": [],
  "ports": [
    "8123:80"
  ]
}
```

When you are done, press **Save** and then **Start**. In the **Logs** section, you can see what the add-on is doing. Watch out for an entry like the one below, which will tell you your hostname on the Tor network.

```bash
INFO: -----------------------------------------------------------
INFO: Your Home Assistant instance is available on Tor!
INFO: Address: abcdef1234567890.onion
INFO: -----------------------------------------------------------
```

Don't worry if you missed it, restarting the add-on will display it again. The details are also stored and available in the `/ssl/tor/hidden_service/hostname` file.

## Tor clients

To access you Home Assistant via the Tor Hidden Service, you will need a Tor client. There are multiple clients, for different devices and platforms, available. The [Tor Browser](https://www.torproject.org/projects/torbrowser.html.en) is by far the simplest option, which is available for Windows, MacOS & Linux.

Simply download and install the [Tor Browser](https://www.torproject.org/projects/torbrowser.html.en), start it, and enter the "dot onion" address you've gained from the earlier steps (`abcdef1234567890.onion` in this case). Voila!

Some other clients:

- [Orbot](https://guardianproject.info/apps/orbot/) for Android
- Orfox for Android has been deprecated. Please use [Tor Browser for Android](https://www.torproject.org/download/#android). More information about the deprecation [here](https://trac.torproject.org/projects/tor/ticket/29955).
- [Onion Browser](https://mike.tig.as/onionbrowser/) for iOS

## Cranking up security

The setup described in this blog post is easy and relatively secure, but anyone who knows your `.onion` address can still connect to your Home Assistant instance (Remember to use passwords!). With all of the [discussion](https://blog.torproject.org/quick-simple-guide-tor-and-internet-things-so-far) about putting your IoT on the Tor Network, maybe you want to add an extra layer of defense, especially if you‚Äôre going to be the only one that uses it. Tor offers an additional layer of security, called "Hidden Service Authentication", usually referred to as "Stealth"-mode.

This "Stealth"-mode adds an extra layer of security to your Hidden Service by only responding to a client that passes a unique secret cookie as it connects. Obviously, this requires additional configuration on the Tor client applications.

The Tor Project itself provides details about a variety of topics in their [documentation](https://www.torproject.org/docs/documentation.html.en).
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Home Assistant and The Things Network (TTN)]]></title>
    <link href="https://ivangrod.github.io/blog/2017/11/10/ttn-with-mqtt/"/>
    <updated>2017-11-10T12:00:00+00:00</updated>
    <id>https://ivangrod.github.io/blog/2017/11/10/ttn-with-mqtt</id>
    <content type="html"><![CDATA[The Home Assistant integration for [The Things Network (TTN)](https://www.thethingsnetwork.org/) uses their [Storage](https://www.thethingsnetwork.org/docs/applications/storage/) feature to get the sensor data. The easiest way to observe TTN sensors would be [MQTT](https://www.thethingsnetwork.org/docs/applications/mqtt/) as it doesn't requires any additional configuration.

At the moment Home Assistant only supports one [MQTT broker](/docs/mqtt/). This means that you can't subscribe to topics which are located on different brokers.

<!--more-->

## Subscribe to the TTN Broker

To check what your devices are sending, subscribe to the topic `+/devices/+/up` with a command-line tool like `mosquitto_sub`. The `<Region>` is the postfix of the **Handler** entry in your **Application overview**. `<AppID>` is the **Application ID** and `<AppKey>` is your access key. 

```bash
$ mosquitto_sub -v -h <Region>.thethings.network -t '+/devices/+/up' -u '<AppID>' -P '<AppKey>'
{
    "app_id": "ha-demo",
    "dev_id": "device01",
    "hardware_serial": "AJDJENDNHRBFBBT",
    "port": 1,
    [...]
```

The payload contains details about the device itself and the sensor data. The sensor data is stored in `payload_fields`. Depending on the device configuration it may contain a single value or multiple values.

## The relay

To be able to work locally with the MQTT data that is received from the devices connected to TTN, we need to transfer it to the local broker. With this simple script below all messages from a given device are re-published on your local MQTT broker after they are received. Modify the script with your details as outlined in the previous section.

```python
"""Relay MQTT messages from The Things Network to a local MQTT broker."""
import paho.mqtt.client as mqtt
import paho.mqtt.publish as publish

DEVICE_NAME = '<DeviceID>'

TTN_BROKER = '<Region>.thethings.network'
TTN_USERNAME = '<AppID>'
TTN_PASSWORD = '<AppKey>'
TTN_TOPIC = '+/devices/{}/up'.format(DEVICE_NAME)

LOCAL_BROKER = '192.168.0.2'
LOCAL_TOPIC = 'home/ttn/garden_temp'


def on_connect(client, userdata, flags, rc):
    """Subscribe to topic after connection to broker is made."""
    print("Connected with result code", str(rc))
    client.subscribe(TTN_TOPIC)


def on_message(client, userdata, msg):
    """Relay message to a different broker."""
    publish.single(
        LOCAL_TOPIC, payload=msg.payload, qos=0, retain=False,
        hostname=LOCAL_BROKER, port=1883, client_id='ttn-local',
        keepalive=60, will=None, auth=None, tls=None, protocol=mqtt.MQTTv311)


client = mqtt.Client()
client.username_pw_set(TTN_USERNAME, password=TTN_PASSWORD)
client.on_connect = on_connect
client.on_message = on_message
client.connect(TTN_BROKER, 1883, 60)

client.loop_forever()
```

Save it and run it. As soon as a MQTT message is received from your device you should see it on your local broker (here 192.168.0.2) if you subscribe to `#` or the topic given in the script above `home/ttn/garden_temp`.

```bash
mosquitto_sub -h 192.168.0.2 -t "#" -d
```

## The sensor

All we would need now, is a [`mqtt` sensor](/integrations/sensor.mqtt/) with a `value_template`. With a sophisticated custom sensor it would be possible to displaying a little more than just the state. The device is only sending the temperature `{"temperature": 7.5}` but there are other details available which the sensor should show.

```python
"""Support for The Things Network MQTT sensors."""
import asyncio
from datetime import timedelta
import json
import logging

import voluptuous as vol

import homeassistant.components.mqtt as mqtt
from homeassistant.components.mqtt import CONF_STATE_TOPIC
from homeassistant.const import CONF_NAME, CONF_UNIT_OF_MEASUREMENT
from homeassistant.core import callback
import homeassistant.helpers.config_validation as cv
from homeassistant.helpers.entity import Entity

_LOGGER = logging.getLogger(__name__)

DEFAULT_NAME = 'MQTT TTN Sensor'
DEFAULT_FORCE_UPDATE = False
DEPENDENCIES = ['mqtt']

PLATFORM_SCHEMA = mqtt.MQTT_RO_PLATFORM_SCHEMA.extend({
    vol.Optional(CONF_NAME, default=DEFAULT_NAME): cv.string,
    vol.Optional(CONF_UNIT_OF_MEASUREMENT): cv.string,

})


@asyncio.coroutine
def async_setup_platform(hass, config, async_add_devices, discovery_info=None):
    """Set up the TTN MQTT Sensor."""
    async_add_devices([MqttTtnSensor(
        config.get(CONF_NAME), config.get(CONF_STATE_TOPIC),
        config.get(CONF_UNIT_OF_MEASUREMENT))
    ])


class MqttTtnSensor(Entity):
    """Representation of a sensor."""

    def __init__(self, name, state_topic, unit_of_measurement):
        """Initialize the sensor."""
        self._state = None
        self._name = name
        self._unit_of_measurement = unit_of_measurement
        self._attributes = {}
        self._state_topic = state_topic

    def async_added_to_hass(self):
        """Subscribe to MQTT events."""
        @callback
        def message_received(topic, payload, qos):
            """Handle new MQTT messages."""

            try:
                data = json.loads(payload)
            except json.JSONDecodeError:
                _LOGGER.error("Invalid JSON data received: %s", data)

            self._state = data['payload_fields'][next(
                iter(data['payload_fields']))]
            self._attributes = data
            del self._attributes['payload_fields']
            del self._attributes['metadata']
            self.async_schedule_update_ha_state()

        return mqtt.async_subscribe(
            self.hass, self._state_topic, message_received, 0)

    @property
    def should_poll(self):
        """No polling needed."""
        return False

    @property
    def name(self):
        """Return the name of the sensor."""
        return self._name

    @property
    def unit_of_measurement(self):
        """Return the unit this state is expressed in."""
        return self._unit_of_measurement

    @property
    def state_attributes(self):
        """Return the attributes of the entity."""
        return self._attributes

    @property
    def state(self):
        """Return the state of the entity."""
        return self._state
```

Store it in `<config_dir>/custom_components/sensor/mqtt_ttn.py` and it will handle the messages.

## The configuration

Now create the [`mqtt_ttn` sensor](/integrations/sensor.mqtt/) entry for your device.

```yaml
sensor:
  - platform: mqtt_ttn
    name: TTN Sensor
    state_topic: "home/ttn/garden_temp"
```

This solution is not production-ready, scalable or stable but it could fill the gape till Home Assistant is able to connect to multiple MQTT brokers. If you have multiple devices relay all messages to your local broker and add a configuration variable to `mqtt_ttn` sensor which allows you to select the device.
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Home Assistant and SSH]]></title>
    <link href="https://ivangrod.github.io/blog/2017/11/02/secure-shell-tunnel/"/>
    <updated>2017-11-02T08:00:00+00:00</updated>
    <id>https://ivangrod.github.io/blog/2017/11/02/secure-shell-tunnel</id>
    <content type="html"><![CDATA[Most system engineers are very familiar with [SSH (Secure shell)](https://en.wikipedia.org/wiki/Secure_Shell). This tool which contains a server part and a client part is used to access a remote system in a secure way. It can also help you if your are running Home Assistant but don't want to expose it to the public. On a Linux system SSH is often available by default. If you are using a Windows installation additional steps are required which are not covered here.

In this blog post we are going to use the tunneling option of SSH to create a secure connection and forward the Home Assistant frontend to a local system.

<!--more-->

The involved parties are:

- **Remote system**: Where Home Assistant is running, usually in your home network.
- **Local system**: Where you want to see the frontend.

The prerequirements are that you need to allow the forwarding of port 22 from your router to the system where Home Assistant is running in your network. It might also be needed that you enable the SSH daemon by `$ sudo systemctl start sshd` on the remote system and to adjust the host firewall. If you are running [Hass.io](/hassio/) then enable the [SSH Server add-on](/addons/ssh/). You must also have a public IP address or hostname which can be provided by dynamic DNS (e.g., [NO-IP](https://www.noip.com/) or [DuckDNS](https://www.duckdns.org/)).
On your local system you need only a SSH client and you need to be in a network where SSH is allowed.

First let's have a look at the command we are going to use. Use `man ssh` to get more information.

```bash
$ ssh -L 8000:localhost:8123 user@[IP_ADDRESS_REMOTE]
      |  |    |         |    |    |
      |  |    |         |    |    |_ IP address or hostname of your router.
      |  |    |         |    |_ Username on the remote system.
      |  |    |         |_ Port where the application is running.
      |  |    |_ We want the frontend on this system.
      |  |_ The port on our local system to use (above 1024).
      |_ We want to do local port forwarding.
```

A possible example could look like the command below.

```bash
ssh -L 8000:localhost:8123 ha@192.168.0.11
```

The first time you establish the connection you need to accept the fingerprint.

```bash
The authenticity of host '192.168.0.11 (192.168.0.11)' can't be established.
ECDSA key fingerprint is SHA256:asdf2faasd4gk45454fadr78wfadfasdfeg4vvvsae33.
ECDSA key fingerprint is MD5:44:d4:f7:44:d4:aa:b8:de:ef:09:3e:0d:4e:12:11:09.
Are you sure you want to continue connecting (yes/no)?
Warning: Permanently added '192.168.0.162' (ECDSA) to the list of known hosts.
ha@192.168.0.11's password:
Last login: Fri Oct 27 17:50:09 2017
[ha@home-assistant ~]$
```

Now you are able to use your frontend on your local system: `http://localhost:8000`

Things to keep in mind:

- You need a public IP address or hostname (Dynamic DNS will work) if you want to use it from the internet.
- You need to setup port forwarding on your router.
- Don't allow `root` to use SSH. Set `PermitRootLogin no` on the remote system.
- Your local port must be above 1024. Only `root` is allowed to forward privileged ports which are below 1024.
- Use [SSH keys for authentication](http://docs.fedoraproject.org//en-US/Fedora/14/html/Deployment_Guide/s2-ssh-configuration-keypairs.html) instead of passwords to avoid bruteforce attacks.
]]></content>
  </entry>
  
</feed>
